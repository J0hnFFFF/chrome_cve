"""
Multi-Step Exploit Chain

Data structures and orchestrator for complex multi-step exploits (Phase 5.2).
"""

import logging
from typing import List, Optional, Callable, Dict, Any
from dataclasses import dataclass, field
from enum import Enum

logger = logging.getLogger(__name__)


class StepStatus(Enum):
    """Status of an exploit step."""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class ExploitStep:
    """
    Single step in an exploit chain.
    
    Example:
        step = ExploitStep(
            name="Heap Spray",
            code="for (let i = 0; i < 1000; i++) { spray[i] = new ArrayBuffer(0x1000); }",
            expected_state="Heap filled with controlled data",
            verification="spray.length === 1000"
        )
    """
    name: str
    code: str
    expected_state: str
    verification: Optional[str] = None
    description: Optional[str] = None
    status: StepStatus = StepStatus.PENDING
    error: Optional[str] = None


@dataclass
class ExploitChain:
    """
    Multi-step exploit chain.
    
    Example:
        chain = ExploitChain(
            description="UAF exploit with heap spray",
            steps=[
                ExploitStep("Heap Spray", ...),
                ExploitStep("Trigger UAF", ...),
                ExploitStep("Exploit UAF", ...),
            ]
        )
    """
    steps: List[ExploitStep]
    description: str
    total_steps: int = field(init=False)
    current_step: int = 0
    success: bool = False
    
    def __post_init__(self):
        self.total_steps = len(self.steps)
    
    def get_current_step(self) -> Optional[ExploitStep]:
        """Get current step."""
        if 0 <= self.current_step < self.total_steps:
            return self.steps[self.current_step]
        return None
    
    def advance(self) -> bool:
        """Advance to next step."""
        if self.current_step < self.total_steps - 1:
            self.current_step += 1
            return True
        return False
    
    def mark_step_success(self):
        """Mark current step as successful."""
        step = self.get_current_step()
        if step:
            step.status = StepStatus.SUCCESS
    
    def mark_step_failed(self, error: str):
        """Mark current step as failed."""
        step = self.get_current_step()
        if step:
            step.status = StepStatus.FAILED
            step.error = error


class ChainOrchestrator:
    """
    Orchestrates execution of multi-step exploit chains.
    
    Features:
    - Step-by-step execution
    - Intermediate verification
    - Error handling and recovery
    - Progress tracking
    """
    
    def __init__(self, executor=None):
        """
        Initialize orchestrator.
        
        Args:
            executor: Code executor (D8Executor or ChromeExecutor)
        """
        self.executor = executor
    
    def execute_chain(
        self,
        chain: ExploitChain,
        verify_steps: bool = True
    ) -> bool:
        """
        Execute exploit chain.
        
        Args:
            chain: ExploitChain to execute
            verify_steps: Whether to verify each step
            
        Returns:
            True if all steps succeeded
        """
        logger.info(f"Executing chain: {chain.description}")
        logger.info(f"Total steps: {chain.total_steps}")
        
        for i in range(chain.total_steps):
            step = chain.steps[i]
            chain.current_step = i
            
            logger.info(f"[{i+1}/{chain.total_steps}] {step.name}")
            logger.debug(f"Expected state: {step.expected_state}")
            
            # Execute step
            step.status = StepStatus.RUNNING
            success = self._execute_step(step)
            
            if not success:
                logger.error(f"Step {i+1} failed: {step.error}")
                chain.success = False
                return False
            
            step.status = StepStatus.SUCCESS
            
            # Verify step (if enabled)
            if verify_steps and step.verification:
                if not self._verify_step(step):
                    logger.error(f"Step {i+1} verification failed")
                    step.status = StepStatus.FAILED
                    step.error = "Verification failed"
                    chain.success = False
                    return False
            
            logger.info(f"✓ Step {i+1} completed")
        
        chain.success = True
        logger.info(f"✓ Chain completed successfully")
        return True
    
    def execute_step_by_step(
        self,
        chain: ExploitChain,
        callback: Callable[[ExploitStep, int], bool] = None
    ) -> bool:
        """
        Execute chain step-by-step with callback.
        
        Args:
            chain: ExploitChain to execute
            callback: Called after each step, return False to stop
            
        Returns:
            True if all steps succeeded
        """
        for i in range(chain.total_steps):
            step = chain.steps[i]
            chain.current_step = i
            
            # Execute step
            step.status = StepStatus.RUNNING
            success = self._execute_step(step)
            
            if success:
                step.status = StepStatus.SUCCESS
            else:
                step.status = StepStatus.FAILED
                chain.success = False
                return False
            
            # Callback
            if callback:
                should_continue = callback(step, i)
                if not should_continue:
                    logger.info("Execution stopped by callback")
                    return False
        
        chain.success = True
        return True
    
    def _execute_step(self, step: ExploitStep) -> bool:
        """Execute a single step."""
        try:
            if self.executor:
                # Use provided executor
                result = self.executor.execute(step.code)
                return result.exit_code == 0
            else:
                # No executor, assume success (for testing)
                logger.debug(f"No executor, simulating step: {step.name}")
                return True
                
        except Exception as e:
            step.error = str(e)
            logger.error(f"Step execution failed: {e}")
            return False
    
    def _verify_step(self, step: ExploitStep) -> bool:
        """Verify step completion."""
        if not step.verification:
            return True
        
        try:
            if self.executor:
                # Execute verification code
                result = self.executor.execute(step.verification)
                return result.exit_code == 0
            else:
                # No executor, assume verification passes
                return True
                
        except Exception as e:
            logger.error(f"Verification failed: {e}")
            return False
    
    def get_progress(self, chain: ExploitChain) -> Dict[str, Any]:
        """Get chain execution progress."""
        completed = sum(1 for s in chain.steps if s.status == StepStatus.SUCCESS)
        failed = sum(1 for s in chain.steps if s.status == StepStatus.FAILED)
        
        return {
            "total_steps": chain.total_steps,
            "current_step": chain.current_step + 1,
            "completed": completed,
            "failed": failed,
            "progress_percent": (completed / chain.total_steps * 100) if chain.total_steps > 0 else 0,
            "status": "success" if chain.success else ("failed" if failed > 0 else "in_progress")
        }


def create_simple_chain(steps_data: List[Dict[str, str]], description: str) -> ExploitChain:
    """
    Helper to create a simple exploit chain.
    
    Args:
        steps_data: List of dicts with 'name', 'code', 'expected_state'
        description: Chain description
        
    Returns:
        ExploitChain
    """
    steps = [
        ExploitStep(
            name=s["name"],
            code=s["code"],
            expected_state=s.get("expected_state", ""),
            verification=s.get("verification")
        )
        for s in steps_data
    ]
    
    return ExploitChain(steps=steps, description=description)
